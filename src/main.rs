#![warn(clippy::pedantic)]
#![allow(
	clippy::cast_possible_truncation,
	clippy::cast_sign_loss,
	clippy::cast_lossless,
	clippy::large_types_passed_by_value,
	clippy::default_trait_access
)]

mod model;
mod optimize;
mod pipeline;

use std::path::PathBuf;

use clap::{Parser, ValueHint};
use optimize::HeatMap;
use pipeline::Pipeline;

#[derive(Parser)]
enum Args {
	/// Train the pipeline to generate an image.
	Train {
		/// A path to the desired image. It should be 512x512 pixels.
		#[arg(value_hint = ValueHint::FilePath)]
		path: PathBuf,
		/// A path to the output checkpoint file.
		#[arg(short, long, value_hint = ValueHint::FilePath, default_value = "solution.bin")]
		output: PathBuf,
		/// The threshold for the difference between the current image and the
		/// target image.
		///
		/// This is calculated as the sum of the absolute differences between the
		/// red, green, and blue channels of each pixel.
		#[arg(short, long, default_value_t = 2_500_000)]
		threshold: u32,
		/// A path to a checkpoint file. This file should contain `--splats * 8`
		/// bytes, which are generated by the program when it finishes.
		#[arg(short, long, value_hint = ValueHint::FilePath)]
		checkpoint: Option<PathBuf>,
		/// The number of splats to use in the pipeline.
		///
		/// If not provided, the checkpoint file will be used to determine the
		/// number of splats. If both are not provided, a value will be found
		/// using the heatmap.
		#[arg(short, long)]
		splats: Option<usize>,
	},
	/// Renders an image from a checkpoint file.
	Render {
		/// A path to the checkpoint file.
		#[arg(value_hint = ValueHint::FilePath)]
		checkpoint: PathBuf,
		/// A path to the output image file.
		#[arg(short, long, value_hint = ValueHint::FilePath, default_value = "output.png")]
		output: PathBuf,
	},
}

fn main() {
	tracing_subscriber::fmt()
		.with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
		.without_time()
		.init();

	let args = Args::parse();

	pollster::block_on(async {
		let (image, num_splats, splats) = match args {
			Args::Train {
				ref path,
				ref checkpoint,
				splats,
				..
			} => {
				let image = image::open(path).unwrap().into_rgba8();

				assert_eq!(image.width() as usize, Pipeline::WIDTH);
				assert_eq!(image.height() as usize, Pipeline::HEIGHT);

				let init_splats = checkpoint
					.as_ref()
					.map(|path| std::fs::read(path).expect("read checkpoint"))
					.map(Vec::into_boxed_slice);

				let splats = if let Some(ref init) = init_splats {
					if let Some(splats) = splats {
						assert_eq!(
							init.len() % 8,
							0,
							"checkpoint file expected to contain {} bytes, found {}",
							splats * 8,
							init.len()
						);

						splats
					} else {
						assert_eq!(
							init.len() % 8,
							0,
							"checkpoint file must be a multiple of 8 bytes"
						);

						init.len() / 8
					}
				} else {
					let heatmap = HeatMap::from_image(&image);
					let recommended = heatmap.recommended_splat_count();

					tracing::info!("Recommended splat count: {}", recommended);

					recommended
				};

				(image, splats, init_splats)
			}
			Args::Render { ref checkpoint, .. } => {
				let splats = std::fs::read(checkpoint).expect("read checkpoint");

				assert_eq!(
					splats.len() % 8,
					0,
					"checkpoint file must be a multiple of 8 bytes"
				);

				(
					image::RgbaImage::new(Pipeline::WIDTH as u32, Pipeline::HEIGHT as u32),
					splats.len() / 8,
					Some(splats.into_boxed_slice()),
				)
			}
		};

		let mut pipeline = Pipeline::new(image, num_splats, splats)
			.await
			.expect("create pipeline");

		match args {
			Args::Train {
				threshold, output, ..
			} => {
				while pipeline.difference() > threshold {
					pipeline.pass().await;
				}

				std::fs::write(output, pipeline.solution()).unwrap();
			}
			Args::Render { output, .. } => {
				pipeline.render();
				pipeline
					.render_to_image()
					.await
					.save(output)
					.expect("save image");
			}
		}
	});
}
