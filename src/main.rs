#![warn(clippy::pedantic)]
#![allow(
	clippy::cast_possible_truncation,
	clippy::cast_sign_loss,
	clippy::cast_lossless,
	clippy::large_types_passed_by_value,
	clippy::default_trait_access
)]

mod model;
mod optimize;
mod pipeline;

use std::path::PathBuf;

use clap::{Parser, ValueHint};
use pipeline::Pipeline;

#[derive(Parser)]
enum Args {
	/// Train the pipeline to generate an image.
	Train {
		/// A path to the desired image. It should be 512x512 pixels.
		#[arg(value_hint = ValueHint::FilePath)]
		path: PathBuf,
		/// A path to the output checkpoint file.
		#[arg(short, long, value_hint = ValueHint::FilePath, default_value = "solution.bin")]
		output: PathBuf,
		/// The threshold for the difference between the current image and the
		/// target image.
		///
		/// This is calculated as the sum of the absolute differences between the
		/// red, green, and blue channels of each pixel.
		#[arg(short, long, default_value_t = 5_000_000)]
		threshold: u32,
		/// A path to a checkpoint file. This file should contain 4000 bytes, which
		/// are generated by the program when it finishes.
		#[arg(short, long, value_hint = ValueHint::FilePath)]
		checkpoint: Option<PathBuf>,
	},
	/// Renders an image from a checkpoint file.
	Render {
		/// A path to the checkpoint file.
		#[arg(value_hint = ValueHint::FilePath)]
		checkpoint: PathBuf,
		/// A path to the output image file.
		#[arg(short, long, value_hint = ValueHint::FilePath, default_value = "output.png")]
		output: PathBuf,
	},
}

fn main() {
	tracing_subscriber::fmt::init();

	let args = Args::parse();

	pollster::block_on(async {
		let (image, splats) = match args {
			Args::Train {
				ref path,
				ref checkpoint,
				..
			} => {
				let image = image::open(path).unwrap().into_rgba8();

				assert_eq!(image.width() as usize, Pipeline::WIDTH);
				assert_eq!(image.height() as usize, Pipeline::HEIGHT);

				(
					image,
					checkpoint.as_ref().map(|path| {
						std::fs::read(path)
							.expect("read checkpoint")
							.try_into()
							.unwrap_or_else(|_| panic!("parse {} bytes from checkpoint", pipeline::SPLATS * 8))
					}),
				)
			}
			Args::Render { ref checkpoint, .. } => (
				image::RgbaImage::new(Pipeline::WIDTH as u32, Pipeline::HEIGHT as u32),
				Some(
					std::fs::read(checkpoint)
						.expect("read checkpoint")
						.try_into()
						.unwrap_or_else(|_| panic!("parse {} bytes from checkpoint", pipeline::SPLATS * 8)),
				),
			),
		};

		let mut pipeline = Box::pin(Pipeline::new(image, splats))
			.await
			.expect("create pipeline");

		match args {
			Args::Train {
				threshold, output, ..
			} => {
				while pipeline.difference() > threshold {
					pipeline.pass().await;
				}

				std::fs::write(output, pipeline.solution()).unwrap();
			}
			Args::Render { output, .. } => {
				pipeline.render();
				pipeline
					.render_to_image()
					.await
					.save(output)
					.expect("save image");
			}
		}
	});
}
